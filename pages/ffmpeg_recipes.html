<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta name="author" content="Jeremy Osborne">
<link href="/css/style.css" rel="stylesheet">
<link href="/rss.xml" title="jeremy&apos;s neglected site" rel="alternate" type="application/rss+xml">

        <title>ffmpeg recipes</title>
            <script>
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-33545821-1']);
_gaq.push(['_setDomainName', 'jeremyosborne.com']);
_gaq.push(['_trackPageview']);

(function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
        </script>
</head>
    <body>
                <noscript>
            <div class="warning">
This blog works better with JavaScript enabled, but not that much better.
            </div>
        </noscript>

        <header>
    <h1 id="main-header"><a href="/">jeremy&#x27;s neglected site</a></h1>
</header>

        <div id="main-content">
            <article class="page">
                <header>
                    <h1>ffmpeg recipes</h1>
                    <h2 class="subheading"><!--by Jeremy Osborne,-->2014.02.16 13:46:06</h2>
                </header>
                <section>
                    <p>The following are <a href="http://ffmpeg.org/" target="_blank">ffmpeg</a> commands that I found useful for video editing (mainly for recorded screencasts and Youtube videos).  I&#39;ve given a rough description of each command, followed by my explanation of the commandline options, followed by the command itself. I assume you will modify the commands to suit your needs.</p>
<p>All commands based on version <strong>Mar 22 2013 08:56:38</strong> of ffmpeg, which is a newer version compared to a lot of the help material I found for ffmpeg on the web. Most of these commands are tested on Windows versions of ffmpeg, despite that I often use Unix multi-line escapes to break up long commands.</p>
<h3 id="concatenate-join-a-selection-of-videos-in-different-formats-and-containers-into-one-final-video">Concatenate (join) a selection of videos (in different formats and containers) into one final video</h3>
<p>This command concatenates and performs a lossy transcoding on the videos. For my purposes this is okay, but please know you will be degrading the quality of your videos by doing this.</p>
<p>The original template for this command came from the ffmpeg wiki page <a href="http://ffmpeg.org/trac/ffmpeg/wiki/How%20to%20concatenate%20%28join,%20merge%29%20media%20files" target="_blank">How to concatenate (join, merge) media files</a>.</p>
<pre><code>#    -i 2.mp4 -i 3.mp4 -i 4.mp4 -i 5.mp4 -i 6.mp4
#        The input videos. I have 5 videos in this command.
#        Input order is important when ffmpeg needs to reference
#        the video by index.
#        2.mp4 will be referenced by index 0 because it is first.
#        5.mp4, being the fourth video, is referenced by index 3.
#        ffmpeg uses 0-based indexing (as most nerd things do for
#        historical reasoning).
#    -filter_complex &quot;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] [3:0] [3:1] [4:0] [4:1] concat=n=5:v=1:a=1 [v] [a]&quot;
#        Perform a complex filtering of input to output.
#        Since we know 2.mp4 maps to index of zero, I could describe the
#        above as:
#
#        [0:0] [0:1]
#            Takes the video stream of 2.mp4, denoted as [0:0], and the audio
#            stream of 2.mp4, denoted as [0:1], and includes them in the concat
#            process. These values were true for my videos, although it is
#            possible you will be concatenating different streams than me.
#
#        And with that mapping, we are stating &quot;Take the audio and
#        video streams of all of my input videos and...&quot;
#
#        concat=n=5:v=1:a=1 [v] [a]
#            n=5 will need to be changed to correspond to the number of videos
#            you are concatenating (you have to be explicit). I had 5, so I
#            put 5. I&#39;m telling ffmpeg that there is 1 video stream with v=1
#            and there is one audio stream with a=1 (I believe the order is
#            important, but I&#39;m not entirely sure).
#            [v] is essentially a variable reference to the video stream
#            this is formed by the concatenation.
#            [a] is essentially a variable reference to the audio stream
#            this is formed by the concatenation.
#    -map &quot;[v]&quot; -map &quot;[a]&quot;
#        Use the concatenated streams for the output, not the original input
#        file streams as is usually assumed by ffmpeg. First stream will be
#        the video, second will be the audio.
#    -c:v libx264
#        Use the codec for h264 video encoding.
#    -crf 23
#        From the ffmpeg x264 encoding wiki:
#        crf stands for constant rate factor. The range of the
#        quantizer scale is 0-51; where 0 is lossless, 23 is
#        default, and 51 is worst possible.
#        Consider 18 to be visually lossless.
#    -preset slow
#        From the ffmpeg x264 encoding wiki:
#        A preset is a collection of options that will provide
#        a certain encoding speed to compression ratio.
#    -c:a aac
#        Use the codec for aac encoding of the audio.
#    -strict experimental
#        The aac encoder is, at the time of writing, considered experimental
#        and is not available by default unless we include the
#        -strict experimental flag.
#    -ac 2
#        Copy the audio as stereo.
#    -ar 44100
#        Audio sampling frequency of 44100 Hz.
#    -ab 128k
#        Encode for a transfer bitrate of 128k bits per second.
#    -threads 0
#        Let ffmpeg decide how many threads to use
#        for encoding (if it even chooses to use more than one).
#    output.mkv
#        Output into the Matroska container format
#        (detected by the file extension).

# Unix friendly command.
ffmpeg -i 2.mp4 -i 3.mp4 -i 4.mp4 -i 5.mp4 -i 6.mp4 \
-filter_complex &#39;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] [3:0] [3:1] [4:0] [4:1] concat=n=5:v=1:a=1 [v] [a]&#39; \
-map &#39;[v]&#39; -map &#39;[a]&#39; \
-c:v libx264 -crf 23 -preset slow \
-c:a aac -strict experimental -ac 2 -ar 44100 -ab 128k \
-threads 0 output.mkv

# DOS friendly command (because this command was picky about quotes.)
ffmpeg -i 2.mp4 -i 3.mp4 -i 4.mp4 -i 5.mp4 -i 6.mp4 ^
-filter_complex &quot;[0:0] [0:1] [1:0] [1:1] [2:0] [2:1] [3:0] [3:1] [4:0] [4:1] concat=n=5:v=1:a=1 [v] [a]&quot; ^
-map &quot;[v]&quot; -map &quot;[a]&quot; ^
-c:v libx264 -crf 23 -preset slow ^
-c:a aac -strict experimental -ac 2 -ar 44100 -ab 128k ^
-threads 0 output.mkv</code></pre>
<h3 id="crop-a-section-of-a-video">Crop a section of a video</h3>
<p>Sometimes I want to crop just a rectangle of the original video and turn that into a whole other video.</p>
<pre><code>#    -i capture.avi
#        The input video.
#    -filter:v crop=1280:960:0:32
#        Apply a filter to the video streams.
#        Take a 1280 pixel wide by 960 pixel tall
#        video window from the input, and offset this
#        1280x960 rectangle 0 pixels from the left side
#        (aka. the cropping begins from the original left side)
#        and 32 pixels down from the top.
#    -c:v libx264
#        Use the libx264 video codec (h.264 encoder).
#    -preset slow
#        From the ffmpeg x264 encoding wiki:
#        A preset is a collection of options that will provide
#        a certain encoding speed to compression ratio.
#    -crf 18
#        From the ffmpeg x264 encoding wiki:
#        crf stands for constant rate factor. The range of the
#        quantizer scale is 0-51; where 0 is lossless, 23 is
#        default, and 51 is worst possible.
#        Consider 18 to be visually lossless.
#    -b:a 128k
#        Set audio bitrate to 128k.
#    -c:a libmp3lame
#        Use the lame library for MP3 encoding.
#    -threads 0
#        Let ffmpeg decide how many threads to use
#        for encoding (if it even chooses to use more than one).
#    -pix_fmt yuv420p
#        Pixel format / color scheme.
#        yuv420p seems to be a very well accepted color scheme,
#        and is also accepted by Youtube (I&#39;ve been focusing on Youtube
#        friendly videos). After some encoding/decoding problems,
#        I&#39;ve been sticking this in most of my reencodings just to
#        make sure.
#    output.mkv
#        Output into the Matroska container format
#        (detected by the file extension).

ffmpeg -i capture.avi -filter:v crop=1280:960:0:32 \
    -c:v libx264 -preset slow -crf 18 \
    -b:a 128k -c:a libmp3lame \
    -threads 0 -pix_fmt yuv420p output.mkv</code></pre>
<h3 id="dosbox-fraps-conversions">DOSBox + Fraps conversions</h3>
<h4 id="tools-and-setup">Tools and setup</h4>
<ul>
<li><a href="http://dosbox.com/" target="_blank">DOSBox</a> version 0.74<ul>
<li>The DOS emulator that allows me to play old DOS games.</li>
<li>Change the frameskip of a game to 2 (or maybe 1). This will cutdown on lag sync problems and keep the game from grinding the system to a hault.</li>
<li>Change the number of cycles devoted to the game (test out to see what works). For example, for my Warlords recording I gave the game 3000 fixed cycles. This seemed to work, somewhat.</li>
<li>Use the ddraw renderer.</li>
<li>If the game is old, try different scalings. I&#39;ve used the hq2x and hq3x to great effect.</li>
</ul>
</li>
<li><a href="http://dfendreloaded.sourceforge.net/" target="_blank">D-Fend Reloaded</a> version 1.3.3<ul>
<li>DOSBox frontend. Not required, but makes my life easier.</li>
</ul>
</li>
<li><a href="http://ffmpeg.org/" target="_blank">ffmpeg</a> version Jan 20 2013 23:39:19<ul>
<li>Commandline video file editor and converter.</li>
</ul>
</li>
<li><a href="http://www.fraps.com/" target="_blank">Fraps</a> version 3.5.9<ul>
<li>I just couldn&#39;t get DOSBox video to sync to the voice over audio with Audacity, so I resorted to Fraps for ingame commentary.</li>
</ul>
</li>
<li>Microphone<ul>
<li>In the Windows Input Devices setup, I set the microphone properties to 2 channel, 16 bit, 44100 Hz.</li>
</ul>
</li>
</ul>
<h4 id="post-processing-with-ffmpeg">Post processing with ffmpeg</h4>
<p>Test: 45 minute example of Master of Magic (10000 cycles, 2 frameskip, ddraw renderer, hq3x scaling) produced an in sync audio+video recording at 13.6 GB in size.</p>
<p>The conversion below decreased the size of the video .5 GB and at the same time doubled the video scale, while also removing the black lines generated by the scaling of the hq3x filter in my monitor.</p>
<pre><code>#    -i capture.avi
#        input file
#    -filter:v crop=1280:960:0:32
#        Take the video stream and crop it within a
#        box of dimensions 1280x960, and position
#        the box 0 pixels from the left and 32 pixels
#        from the top.
#    -sws_flags lanczos+full_chroma_inp
#        using lanczos with full chroma input flag
#    -s 2560x1920
#        Size to scale to
#        (which is double the cropped, scaled
#        video size of 1280x960).
#    -c:v libx264 -preset slow -crf 18
#        Use the x264 encoder and some settings
#        that I can&#39;t quite explain.
#    -b:a 128k
#        Set audio bitrate to 128k.
#    -c:a libmp3lame
#        Use the lame library for MP3 encoding.
#    -threads 0
#        ffmpeg decide how many threads to use
#        for encoding (if more than one).
#    -pix_fmt yuv420p
#        Pixel formatting for the video.
#    upload.mkv
#        The output file.

ffmpeg -i capture.avi -filter:v crop=1280:960:0:32 -sws_flags lanczos+full_chroma_inp -s 2560x1920 -c:v libx264 -preset slow -crf 18 -b:a 128k -c:a libmp3lame -threads 0 -pix_fmt yuv420p upload.mkv</code></pre>
<h3 id="extract-the-audio-as-a-wav-file-from-a-video">Extract the audio as a wav file from a video</h3>
<pre><code>#    -i capture.avi
#        The original video.
#    -ac 2
#        Copy the audio as stereo.
#    -ar 44100
#        Audio sampling frequency of 44100 Hz.
#    -vn
#        Don&#39;t copy over any video.
#    capture_audio.wav
#        Save as a wav format audio encoding (determined by file extension).

ffmpeg -i capture.avi -ac 2 -ar 44100 -vn capture_audio.wav</code></pre>
<h3 id="extract-just-the-video-without-the-audio">Extract just the video without the audio</h3>
<pre><code>#    -i capture.avi
#        The original video.
#    -an
#        No audio is copied to the output.
#    -c:v copy
#        Copy the video streams without reencoding.
#    just_video.avi
#        Output into a new file.

ffmpeg -i capture.avi -an -c:v copy capture_video.avi</code></pre>
<h3 id="iterate-through-a-bunch-of-videos-and-convert-them">Iterate through a bunch of videos and convert them</h3>
<pre><code># Windows Powershell
# For every MP4 file in the directory
# convert to h264
# copy the audio
# color scheme in yuv420p
# and output file with the same basename
# except switch container (and file extension) to Matroska.

for %F IN (*.mp4) DO (ffmpeg -i %F -c:v libx264 -preset slow -crf 23 -c:a copy -threads 0 -pix_fmt yuv420p %~nF.mkv)

# And unix
for f in *.mp4; do   
    ffmpeg -i $f -c:v libx264 -preset slow -crf 23 -c:a copy -threads 0 -pix_fmt yuv420p `basename $f .mp4`.mkv; 
done</code></pre>
<h3 id="mix-a-separate-audio-and-video-file-together-into-one-output">Mix a separate audio and video file together into one output</h3>
<pre><code>#    -i capture_video.avi
#        The first input file.
#    -i remixed_audio.mp3
#        The second input file.
#    -map 0
#        Map all of the streams from the first
#        input into the output video, in order.
#    -map 1
#        Map all of the streams from the second
#        input into the output video, in order.
#    -c copy
#        Do not reencode any streams, use the same
#        encoding.
#    output.mkv
#        Output into the Matroska container format
#        (detected by the file extension).

ffmpeg -i capture_video.avi -i remixed_audio.mp3 \
    -map 0 -map 1 -c copy intermediate2.mkv</code></pre>
<h3 id="upscale-a-video-make-the-pixel-dimensions-bigger-in-the-output-">Upscale a video (make the pixel dimensions bigger in the output)</h3>
<p>This particular formula worked for me when I was needing to upscale a video with a lot of text in it. The text was still readable. I&#39;m not an expert on video editing, but after some reading, and given I was concerned with quality, it appears that the Lanczos filter is probably the best that ffmpeg has to offer for detailed things like text. The downside is that it is pretty slow.</p>
<pre><code>#    -i capture.avi
#        The input video.
#    -sws_flags lanczos+full_chroma_inp
#        Use the lanczos filter with full chroma input
#        during the resize process.
#    -s 2560x1840
#        Width x Height in pixels to scale
#        the output video to.
#    -c:v libx264
#        Use the libx264 video codec (h.264 encoder).
#    -preset slow
#        From the ffmpeg x264 encoding wiki:
#        A preset is a collection of options that will provide
#        a certain encoding speed to compression ratio.
#    -crf 18
#        From the ffmpeg x264 encoding wiki:
#        crf stands for constant rate factor. The range of the
#        quantizer scale is 0-51; where 0 is lossless, 23 is
#        default, and 51 is worst possible.
#        Consider 18 to be visually lossless.
#    -b:a 128k
#        Set audio bitrate to 128k.
#    -c:a libmp3lame
#        Use the lame library for MP3 encoding.
#    -threads 0
#        Let ffmpeg decide how many threads to use
#        for encoding (if it even chooses to use more than one).
#    -pix_fmt yuv420p
#        Pixel format / color scheme.
#        yuv420p seems to be a very well accepted color scheme,
#        and is also accepted by Youtube (I&#39;ve been focusing on Youtube
#        friendly videos). After some encoding/decoding problems,
#        I&#39;ve been sticking this in most of my reencodings just to
#        make sure.
#    output.mkv
#        Output into the Matroska container format
#        (detected by the file extension).

ffmpeg -i capture.avi -sws_flags lanczos+full_chroma_inp \
    -s 2560x1840 -c:v libx264 -preset slow -crf 18 -b:a 128k \
    -c:a libmp3lame -threads 0 -pix_fmt yuv420p output.mkv</code></pre>
<h2 id="references">References</h2>
<p>The following links were the ones that helped me the most with figuring out how to use ffmpeg.</p>
<ul>
<li><a href="http://blog.superuser.com/2012/02/24/ffmpeg-the-ultimate-video-and-audio-manipulation-tool/" target="_blank"><a href="http://blog.superuser.com/2012/02/24/ffmpeg-the-ultimate-video-and-audio-manipulation-tool/" target="_blank">http://blog.superuser.com/2012/02/24/ffmpeg-the-ultimate-video-and-audio-manipulation-tool/</a></a></li>
<li><a href="http://ingomar.wesp.name/2011/04/dosbox-gameplay-video-capture.html" target="_blank"><a href="http://ingomar.wesp.name/2011/04/dosbox-gameplay-video-capture.html" target="_blank">http://ingomar.wesp.name/2011/04/dosbox-gameplay-video-capture.html</a></a></li>
<li><a href="http://ffmpeg.org/trac/ffmpeg/wiki/EncodeforYouTube" target="_blank"><a href="http://ffmpeg.org/trac/ffmpeg/wiki/EncodeforYouTube" target="_blank">http://ffmpeg.org/trac/ffmpeg/wiki/EncodeforYouTube</a></a></li>
<li><a href="http://ffmpeg.org/trac/ffmpeg/wiki/x264EncodingGuide" target="_blank"><a href="http://ffmpeg.org/trac/ffmpeg/wiki/x264EncodingGuide" target="_blank">http://ffmpeg.org/trac/ffmpeg/wiki/x264EncodingGuide</a></a></li>
</ul>
                </section>
            </article>
        </div>
        <footer id="main-footer">
    <!--
    <small>&copy; 2015 Jeremy Osborne</small>
    -->
</footer>

    </body>
</html>
